"""



A module for interpreting and executing code in a subprocess. This module provides a class `SubprocessCodeInterpreter` which
inherits from `BaseCodeInterpreter`. It facilitates running of arbitrary code in an isolated process, handling standard output and
standard error streams, and terminating the process when necessary. The interpreter also manages an output queue where all the
processed output gets enqueued for consumption by the caller.

The `SubprocessCodeInterpreter` establishes its subprocess with a specified command, buffering settings, and environment variables.
It uses threads to continuously read the output and error streams of the subprocess and process any incoming data.

Attributes:
    start_cmd (str): The command used to start the subprocess.
    process (subprocess.Popen): The subprocess in which the code is executed.
    debug_mode (bool): A flag to determine if the debug information should be printed.
    output_queue (queue.Queue): A thread-safe queue to store processed output lines.
    done (threading.Event): An event to indicate when code execution has finished.

Methods:
    __init__(self): Initializes a new instance of the `SubprocessCodeInterpreter`.
    detect_active_line(self, line): A placeholder method to detect active lines. Should be implemented in a subclass.
    detect_end_of_execution(self, line): A placeholder method to detect end of code execution. Should be implemented in a subclass.
    line_postprocessor(self, line): A placeholder method to process lines. Can be overridden by a subclass for custom line processing.
    preprocess_code(self, code): A placeholder method to preprocess code before execution. Can be overridden by a subclass.
    terminate(self): Terminates the subprocess and closes the stdin, stdout streams.
    start_process(self): Starts a new subprocess for code execution and initiates the reading threads.
    run(self, code): Responsible for preprocessing code, starting the subprocess if necessary, handling retries, and yielding
        output from the subprocess until execution finishes.
    handle_stream_output(self, stream, is_error_stream): A method that reads from the subprocess's output/error stream and processes
        the output lines before enqueuing them to the `output_queue`.


Note: Documentation automatically generated by https://undoc.ai
"""
import os
import queue
import subprocess
import threading
import time
import traceback

from .base_code_interpreter import BaseCodeInterpreter


class SubprocessCodeInterpreter(BaseCodeInterpreter):
    """
    Class to interpret and execute code using a subprocess, handling standard and error output.
        This class inherits from a base code interpreter and uses subprocesses to run and manage code execution in an isolated process.
        It captures both standard output and standard error, queuing received lines of output for consumption by external entities.
        Attributes:
            start_cmd (str): The command to start the subprocess.
            process (subprocess.Popen): Handler for the active subprocess.
            debug_mode (bool): Toggle for debug output. True for verbose logging.
            output_queue (queue.Queue): A queue to hold the output generated by the subprocess.
            done (threading.Event): An event flag to indicate when the code execution is complete.
        Methods:
            __init__(): Initializes the SubprocessCodeInterpreter with default values.
            detect_active_line(line): Abstract method to detect an active line in the process output.
            detect_end_of_execution(line): Abstract method to detect the end of the code execution.
            line_postprocessor(line): A method to perform optional processing on a line of output.
            preprocess_code(code): A method to perform preprocessing on the code before execution.
            terminate(): Terminates the subprocess and closes the associated I/O streams.
            start_process(): Starts a subprocess to execute code, sets up environment variables, and starts output handling threads.
            run(code): Executes the provided code block in the subprocess and yields the output.
            handle_stream_output(stream, is_error_stream): Handles and queues the output from the subprocess streams.
    """
    def __init__(self):
        """
        Initializes the instance attributes for the class that this method is a part of.
        The __init__ method sets up the necessary properties used by the instance. It assigns default values
        for starting commands, the process handler, debug mode status, the output queue, and the event
        signal that indicates completion of a process.
        Attributes:
            start_cmd (str): An empty string to hold the starting command that will later be used to
                initiate a process.
            process (None): Initialized as None, to be assigned a process handler that will execute
                the command.
            debug_mode (bool): A flag to indicate whether to print debug information, initially set to False.
            output_queue (queue.Queue): A FIFO queue to hold the output lines from the process.
            done (threading.Event): An event flag that's initially unset; used to signal when the
                process execution is complete.
        """
        self.start_cmd = ""
        self.process = None
        self.debug_mode = False
        self.output_queue = queue.Queue()
        self.done = threading.Event()

    def detect_active_line(self, line):
        """
            Determines whether the given line is active or not.
            This method analyzes the specified line to decide whether it is currently in active use within the system or context. The criteria for making this determination is not specified here and should be defined by the implementation details of this method.
            Args:
                line (str): The line of text or data to be examined.
            Returns:
                The method is expected to return a value that indicates whether the line is active or not. The actual return type and value are not specified in this docstring and should be determined by the method's implementation.
        """
        return None

    def detect_end_of_execution(self, line):
        return None

    def line_postprocessor(self, line):
        """
        Processes a given line of text and returns the processed line. The actual implementation
        """
        return line

    def preprocess_code(self, code):
        """
        Preprocesses the given code for further processing or execution.
        This method is intended to perform any necessary transformations on the
        source code input before it is passed on to the next stage of the programming
        workflow. The exact nature of the preprocessing is not specified here and can
        range from formatting, tokenization, removal of whitespace or comments, etc.
        Args:
            code (str): A string containing the source code to be preprocessed.
        Returns:
            str: The preprocessed version of the input code.
        """
        return code

    def terminate(self):
        """
        Terminate the process managed by the object instance.
        This method is responsible for terminating the associated process. It also
        ensures that the input and output streams of the process are properly closed to
        release any system resources that are being used.
        Raises:
            AttributeError: If the 'process' attribute does not have 'terminate',
            'stdin', or 'stdout' methods.
        """
        self.process.terminate()
        self.process.stdin.close()
        self.process.stdout.close()

    def start_process(self):
        if self.process:
            self.terminate()

        my_env = os.environ.copy()
        my_env["PYTHONIOENCODING"] = "utf-8"
        self.process = subprocess.Popen(
            self.start_cmd.split(),
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=0,
            universal_newlines=True,
            env=my_env,
        )
        threading.Thread(
            target=self.handle_stream_output,
            args=(self.process.stdout, False),
            daemon=True,
        ).start()
        threading.Thread(
            target=self.handle_stream_output,
            args=(self.process.stderr, True),
            daemon=True,
        ).start()

    def run(self, code):
        """
        Runs the given code and handles the retry logic and output streaming from the process.
                This method preprocesses the given code, starts a process if it is not already running,
                and then attempts to execute the code in the process. If an error occurs while writing
                to the process's stdin or flushing it, the method will attempt to retry executing the
                code up to a maximum number of retries defined by `max_retries`. For each retry, it
                restarts the process and tries to write and flush the code again.
                Once the code is successfully written and flushed, the method enters a loop where it
                yields the output from the queue populated by the `handle_stream_output` method. It will
                continue to yield output until the output queue is empty and the `done` event is set,
                signaling that the execution has completed. If the event is not set within a given
                timeout, the method will try to get output from the queue with an additional delay,
                yielding any available output. If the maximum retry count is reached and the code still
                cannot be executed, the method yields a message indicating the failure and returns.
                Args:
                    code (str): The source code to be executed in the process.
                Yields:
                    dict: A dictionary containing the output line or error details from the execution
                          process. If an error occurs during the retries, the stack trace is included
                          in the error details.
                Returns:
                    None: The function does not return any values, as it's a generator method that uses yield.
        """
        retry_count = 0
        max_retries = 3

        # Setup
        try:
            code = self.preprocess_code(code)
            if not self.process:
                self.start_process()
        except:
            yield {"output": traceback.format_exc()}
            return

        while retry_count <= max_retries:
            if self.debug_mode:
                print(f"(after processing) Running processed code:\n{code}\n---")

            self.done.clear()

            try:
                self.process.stdin.write(code + "\n")
                self.process.stdin.flush()
                break
            except:
                if retry_count != 0:
                    # For UX, I like to hide this if it happens once. Obviously feels better to not see errors
                    # Most of the time it doesn't matter, but we should figure out why it happens frequently with:
                    # applescript
                    yield {"output": traceback.format_exc()}
                    yield {"output": f"Retrying... ({retry_count}/{max_retries})"}
                    yield {"output": "Restarting process."}

                self.start_process()

                retry_count += 1
                if retry_count > max_retries:
                    yield {"output": "Maximum retries reached. Could not execute code."}
                    return

        while True:
            if not self.output_queue.empty():
                yield self.output_queue.get()
            else:
                time.sleep(0.1)
            try:
                output = self.output_queue.get(timeout=0.3)  # Waits for 0.3 seconds
                yield output
            except queue.Empty:
                if self.done.is_set():
                    # Try to yank 3 more times from it... maybe there's something in there...
                    # (I don't know if this actually helps. Maybe we just need to yank 1 more time)
                    for _ in range(3):
                        if not self.output_queue.empty():
                            yield self.output_queue.get()
                        time.sleep(0.2)
                    break

    def handle_stream_output(self, stream, is_error_stream):
        """
        Handles the output of a stream, processing it line by line.
        This method is designed to be used with a process stream, such as stdout or stderr. It
        reads the stream line by line, applies a postprocessing function to each line, and then
        determines how to handle the line based on internal detection methods or flags. The
        method can distinguish between active lines, the end of execution, or error signals,
        and places the processed line into an output queue. In debug mode, it prints each
        line received.
        Args:
            stream (file-like object): The stream to be read. This could be stdout or stderr.
            is_error_stream (bool): Flag indicating whether the stream being read is an error stream (e.g., stderr).
        Attributes:
            debug_mode (bool): Flag determining whether debug information will be printed.
            line_postprocessor (Callable): Function used to postprocess each line read from the stream.
            detect_active_line (Callable): Function to determine if the current line is an active line of interest.
            detect_end_of_execution (Callable): Function to assess if the current line signifies the end of execution.
            output_queue (queue.Queue): Queue for storing processed lines to be consumed by other parts of the system.
            done (threading.Event): Event which, when set, indicates that the process is complete.
        """
        for line in iter(stream.readline, ""):
            if self.debug_mode:
                print(f"Received output line:\n{line}\n---")

            line = self.line_postprocessor(line)

            if line is None:
                continue  # `line = None` is the postprocessor's signal to discard completely

            if self.detect_active_line(line):
                active_line = self.detect_active_line(line)
                self.output_queue.put({"active_line": active_line})
            elif self.detect_end_of_execution(line):
                self.done.set()
            elif is_error_stream and "KeyboardInterrupt" in line:
                self.output_queue.put({"output": "KeyboardInterrupt"})
                time.sleep(0.1)
                self.done.set()
            else:
                self.output_queue.put({"output": line})
