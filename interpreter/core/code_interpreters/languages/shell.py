"""

A module for interpreting, running, and processing shell scripts within a Python environment.

This module defines a `Shell` class inheriting from `SubprocessCodeInterpreter`, specializing
in the execution and handling of shell scripts. The execution is responsive, capturing
active lines of code and processing signals marking the end of execution.

Attributes:

    file_extension (str): The default file extension for shell scripts, set to 'sh'.
    proper_name (str): The proper name for the interpreter, set to 'Shell'.

Classes:

    Shell(SubprocessCodeInterpreter):
        A class for running shell script code snippets.

        Upon initialization, it configures the interpreter using the environment and platform
        specifics. It provides methods for preprocessing the shell code, postprocessing
        the output lines, detecting active lines and end of execution markers, and adjustments
        to accommodate shell-specific execution semantics.

Functions:

    preprocess_shell(code):
        Prepares shell code for execution, adding necessary print statements to track active
        lines and an end-of-execution marker.

    add_active_line_prints(code):
        Injects print statements into the shell code to identify currently executing lines,
        aiding in the responsiveness of the interpreter.

    has_multiline_commands(script_text):
        Determines if the shell script contains syntax that implies commands span multiple
        lines, which affects how the interpreter tracks active lines of code.

Note: Documentation automatically generated by https://undoc.ai
"""
import os
import platform
import re

from ..subprocess_code_interpreter import SubprocessCodeInterpreter


class Shell(SubprocessCodeInterpreter):
    """
    A class representing a Shell interpreter for executing Shell Script code within a subprocess.
    This class extends `SubprocessCodeInterpreter` to allow running shell scripts. It has a file extension of '.sh' and
    is properly named 'Shell'. It is responsible for initializing the Shell environment, preprocessing code, as well
    as post processing and detecting special comments within the shell script code.
    Attributes:
        file_extension (str): The file extension for Shell scripts, defaults to 'sh'.
        proper_name (str): The proper name to represent the Shell, defaults to 'Shell'.
        config: Configuration object that contains environment-specific configurations.
    Methods:
        __init__(self, config):
            Initializes a new instance of the Shell class.
            Parameters:
                config: The configuration object used for setting up the shell environment.
            The constructor determines the start command based on the operating system. For Windows, it sets
            `cmd.exe` as the start command, otherwise, it uses whatever the 'SHELL' environment variable is set to,
            defaulting to 'bash' if the variable is not set.
        preprocess_code(self, code): Preprocesses the shell code before it is executed.
            Parameters:
                code (str): The shell code to be preprocessed.
            Returns:
                The preprocessed code ready for execution.
        line_postprocessor(self, line): Post-processes each line of output from the Shell execution.
            Parameters:
                line (str): A single line of output.
            Returns:
                The post-processed line, which in this implementation remains unchanged.
        detect_active_line(self, line):
            Detects if the current line is marked as the active line using a specific pattern.
            Parameters:
                line (str): The line to be checked for an active line indicator.
            Returns:
                The active line number if detected, otherwise `None`.
        detect_end_of_execution(self, line):
            Detects the end-of-execution marker in the output.
            Parameters:
                line (str): The line to be checked for the end-of-execution signal.
            Returns:
                A boolean indicating whether the end-of-execution marker was found.
    """
    file_extension = "sh"
    proper_name = "Shell"

    def __init__(self, config):
        """
        Initializes a new instance of the class with configuration settings.
        This constructor sets up the environment for the instance by initializing
        necessary variables with given configuration parameters. It determines the start
        command to be used for the instance based on the underlying platform.
        Args:
            config (dict): A dictionary of configuration parameters needed for setup.
        Attributes:
            config (dict): A record of configuration settings passed to the instance.
            start_cmd (str): The command to initiate an environment session. It is set to
                'cmd.exe' if the platform is Windows, or the value of the 'SHELL' environment
                variable—or 'bash' if 'SHELL' is not defined—on other systems.
        """
        super().__init__()
        self.config = config

        # Determine the start command based on the platform
        if platform.system() == "Windows":
            self.start_cmd = "cmd.exe"
        else:
            self.start_cmd = os.environ.get("SHELL", "bash")

    def preprocess_code(self, code):
        """
            Preprocesses the given shell code to prepare it for execution monitoring.
            This function takes a block of shell code and processes it by checking if the code contains multiline
            commands. If no multiline commands are detected, it adds print statements to each logical line in the
            shell code, which are used to monitor active execution lines in the debugging environment. Additionally,
            it appends a specific echo command at the end of the code to indicate the end of execution. This allows
            the monitoring system to detect when the shell script has finished running.
            Args:
                code (str): A string containing the shell code to be preprocessed.
            Returns:
                str: The preprocessed shell code with print statements added for each line and an
                     "echo '##end_of_execution##'" appended at the end.
        """
        return preprocess_shell(code)

    def line_postprocessor(self, line):
        """
        Transforms a given line of text and returns the modified line.
        Args:
            line (str): The line of text to be processed.
        Returns:
            str: The processed line after applying the transformations.
        Note:
            This function serves as a placeholder for potential string processing capabilities,
            and its current implementation simply returns the input line without any changes.
        """
        return line

    def detect_active_line(self, line):
        """
        Detects if a given line of text indicates an active line of execution.
        This method checks if the input text ('line') contains a specific marker
        that signifies the current active line of code during execution. The marker
        is expected to be structured as '##active_line' followed by an integer that
        represents the active line number. If the active line marker is found, the
        method extracts the line number and returns it as an integer. If the marker
        is not present in the text, the method returns None.
        Args:
            line (str): The text line to be checked for an active line marker.
        Returns:
            int or None: The extracted active line number if found, otherwise None.
        """
        if "##active_line" in line:
            return int(line.split("##active_line")[1].split("##")[0])
        return None

    def detect_end_of_execution(self, line):
        """
            Determines whether a line of text contains the end of execution marker.
            This method checks if the specific marker '##end_of_execution##' is present in
            the provided string. It is typically used to identify if a line signifies
            the end of a script or a block of code that's being executed.
            Args:
                line (str): The line of text to be checked for the presence of the end of execution marker.
            Returns:
                bool: True if the marker is found in the line, False otherwise.
        """
        return "##end_of_execution##" in line


def preprocess_shell(code):
    """
    Detects multiline commands in the provided shell script and adds active line prints unless multiline commands are found. It then appends an echo statement at the end of the script to mark the end of execution.
    Args:
        code (str): The shell script code to be preprocessed.
    Returns:
        str: The preprocessed shell script code with active line prints and an appended echo statement for end of execution, if multiline commands are not detected.
    """

    # Add commands that tell us what the active line is
    # if it's multiline, just skip this. soon we should make it work with multiline
    if not has_multiline_commands(code):
        code = add_active_line_prints(code)

    # Add end command (we'll be listening for this so we know when it ends)
    code += '\necho "##end_of_execution##"'

    return code


def add_active_line_prints(code):
    """
    Adds markers to the beginning of each line in the provided code string to allow
    for detection of active lines during code execution.
    This function processes the input code, by prepending a specific echo statement
    that includes a unique active line marker. This marker is designed in the format
    "##active_line[number]##" where [number] represents the line number. Each
    line number is incremented according to its position in the input code. These
    markers serve as indicators that can be used to track which line is currently
    being executed, especially when the code is run in a streamed output environment.
    Args:
        code (str): A string representing the code to be processed.
    Returns:
        str: The modified code with added echo statements for active line tracking.
    """
    lines = code.split("\n")
    for index, line in enumerate(lines):
        # Insert the echo command before the actual line
        lines[index] = f'echo "##active_line{index + 1}##"\n{line}'
    return "\n".join(lines)


def has_multiline_commands(script_text):
    """
    Detects the presence of multiline commands in a given script text.
        This function checks whether a provided script text contains any multiline
        command patterns. Common patterns indicating a multiline command are
        '' at the end of a line, pipes '|', logical '&&' or '||' across lines,
        subshells that span multiple lines indicated by '<(' or '(', open curly braces
        '{', and keywords 'if', 'while', 'for', 'do', 'then' that are likely
        to precede blocks of commands.
        Args:
            script_text (str): The script text to be checked for multiline commands.
        Returns:
            bool: True if any multiline command patterns are found, False otherwise.
    """
    # Patterns that indicate a line continues
    continuation_patterns = [
        r"\\$",  # Line continuation character at the end of the line
        r"\|$",  # Pipe character at the end of the line indicating a pipeline continuation
        r"&&\s*$",  # Logical AND at the end of the line
        r"\|\|\s*$",  # Logical OR at the end of the line
        r"<\($",  # Start of process substitution
        r"\($",  # Start of subshell
        r"{\s*$",  # Start of a block
        r"\bif\b",  # Start of an if statement
        r"\bwhile\b",  # Start of a while loop
        r"\bfor\b",  # Start of a for loop
        r"do\s*$",  # 'do' keyword for loops
        r"then\s*$",  # 'then' keyword for if statements
    ]

    # Check each line for multiline patterns
    for line in script_text.splitlines():
        if any(re.search(pattern, line.rstrip()) for pattern in continuation_patterns):
            return True

    return False
