"""



Module for providing a subprocess-based code interpreter for the R programming language.

The R module extends the functionality of SubprocessCodeInterpreter to specifically handle the execution
of R code in a subprocess. It manages the starting, execution, and termination of R subprocesses,
as well as output processing and error handling.

Attributes:
    file_extension (str): The file extension associated with R scripts, typically '.r'.
    proper_name (str): The proper name for the R programming language.

Methods:
    __init__(self, config):
        Initializes a new instance of the R code interpreter with the provided configuration.

        Args:
            config (dict): Configuration dictionary specific to the R interpreter instance.

    preprocess_code(self, code):
        Preprocesses R code before sending it to the subprocess for execution, such as wrapping
        the code in error handling constructs and inserting active line markers.

        Args:
            code (str): The raw R code to be preprocessed.

        Returns:
            str: The preprocessed R code ready for execution.

    line_postprocessor(self, line):
        Postprocesses each line received from the R subprocess, such as filtering out unwanted
        echos and formatting certain outputs.

        Args:
            line (str): A single line of output from the R subprocess.

        Returns:
            str or None: The processed line for output, or None to indicate the line should
            be discarded.

    detect_active_line(self, line):
        Detects active line markers in the output to help with code execution tracing.

        Args:
            line (str): A single line of output from the R subprocess.

        Returns:
            int or None: The active line number if detected, or None if not present.

    detect_end_of_execution(self, line):
        Detects markers indicating the end of R script execution or the occurrence of an execution
        error.

        Args:
            line (str): A single line of output from the R subprocess.

        Returns:
            bool: True if end of execution or an error is detected, False otherwise.

Note: Documentation automatically generated by https://undoc.ai
"""
import re

from ..subprocess_code_interpreter import SubprocessCodeInterpreter


class R(SubprocessCodeInterpreter):
    """
    A subclass specifically designed for handling and interpreting R script code within a larger framework or system that manages subprocess executions.
    Attributes:
        file_extension (str): The associated file extension for R scripts.
        proper_name (str): A human-readable proper name for the R language.
    Methods:
        __init__(config): Constructor for the R interpreter class.
            Parameters:
                config: A configuration object, the details of which are specific to the system integrating this interpreter. The structure and use of this configuration object are not detailed within this docstring.
        preprocess_code(code): Preprocesses the given R code string by adding active line markers and wrapping it in error handling.
            Parameters:
                code (str): The raw R code that needs to be preprocessed before execution.
            Returns:
                (str): The processed R code, ready for execution with added debug and error handling syntax.
        line_postprocessor(line): Processes output lines, filtering out unnecessary lines produced during execution, leaving only the relevant output.
            Parameters:
                line (str): The raw output line from the R code execution that needs to be postprocessed.
            Returns:
                (str or None): The processed line if relevant or None if the line should be discarded.
        detect_active_line(line): Detects if the given line indicates the active line marker inserted during preprocessing.
            Parameters:
                line (str): A line of output potentially containing an active line marker.
            Returns:
                (int or None): The detected active line number or None if no such marker is present in the line.
        detect_end_of_execution(line): Determines whether a line indicates the end of script execution.
            Parameters:
                line (str): A line of output to be checked for end-of-execution markers.
            Returns:
                (bool): True if the line contains an end-of-execution marker, False otherwise.
    """
    file_extension = "r"
    proper_name = "R"

    def __init__(self, config):
        """
        Initializes a new instance of the class with the specified configuration.
                This method sets up the initial state by storing the configuration and
                initializing the command to start R in quiet and vanilla mode, which means no
                saved workspace is loaded and no startup message is displayed.
                Args:
                    config (dict): A configuration dictionary that the instance will use.
        """
        super().__init__()
        self.config = config
        self.start_cmd = "R -q --vanilla"  # Start R in quiet and vanilla mode

    def preprocess_code(self, code):
        """
            Processes a block of code to enable the detection of certain runtime events.
            This method takes code, typically from an R script, and modifies it by adding
            special markers and a tryCatch block for error handling. Each line of input
            code is prefixed with a comment containing a unique identifier to track which
            line is being executed. These identifiers help to determine the active line
            of code during execution. Additionally, it adds an end-of-execution marker
            at the end. The entire block is wrapped in a tryCatch construct, which will
            capture and print any execution errors as a custom error message. Also, it
            records the number of lines in the processed code to help with the parsing
            of echoed back lines that occur within R's output.
            Args:
                code (str): The code to be processed and executed.
            Returns:
                str: A processed version of the input `code` that is ready to be executed, with
                    additional markers for active line detection and error handling as well as
                    an execution end marker.
            Attributes modified:
                self.code_line_count (int): Assigns the count of lines in the `processed_code`.
        """

        lines = code.split("\n")
        processed_lines = []

        for i, line in enumerate(lines, 1):
            # Add active line print
            processed_lines.append(f'cat("##active_line{i}##\\n");{line}')

        # Join lines to form the processed code
        processed_code = "\n".join(processed_lines)

        # Wrap in a tryCatch for error handling and add end of execution marker
        processed_code = f"""
tryCatch({{
{processed_code}
}}, error=function(e){{
    cat("##execution_error##\\n", conditionMessage(e), "\\n");
}})
cat("##end_of_execution##\\n");
"""
        # Count the number of lines of processed_code
        # (R echoes all code back for some reason, but we can skip it if we track this!)
        self.code_line_count = len(processed_code.split("\n")) - 1

        return processed_code

    def line_postprocessor(self, line):
        """
        Processes a line of output from a code execution stream, applying specialized formatting.
        The function includes several filters and modifications:
        - If a `code_line_count` attribute is present and greater than 0, it is decremented and the line
          is not returned (used to skip certain lines).
        - Certain prompts such as Python prompts '>>>', continuation '...', R prompts '>', and standard
          output '+' are detected using regex and the lines containing them are excluded.
        - Lines that start with an R version announcement are excluded.
        - Lines that indicate an R output starting with '[1] "' followed by the content enclosed in quotes 
          are trimmed to only return the inner content, excluding the '[1]' and quotes.
        - Similarly, lines starting with '[1]' but without quotes are trimmed to exclude the '[1]'.
        Args:
            line (str): The line of output from the execution stream to be processed.
        Returns:
            Optional[str]: The modified line ready for further processing or output. Returns None if the line
                           is to be disregarded based on the conditions defined within the function.
        """
        # If the line count attribute is set and non-zero, decrement and skip the line
        if hasattr(self, "code_line_count") and self.code_line_count > 0:
            self.code_line_count -= 1
            return None

        if re.match(r"^(\s*>>>\s*|\s*\.\.\.\s*|\s*>\s*|\s*\+\s*|\s*)$", line):
            return None
        if "R version" in line:  # Startup message
            return None
        if line.strip().startswith('[1] "') and line.endswith(
            '"'
        ):  # For strings, trim quotation marks
            return line[5:-1].strip()
        if line.strip().startswith(
            "[1]"
        ):  # Normal R output prefix for non-string outputs
            return line[4:].strip()

        return line

    def detect_active_line(self, line):
        """
            Detects an "active line" notation in a given line of text.
            This method searches for a specific pattern in the provided text line to identify it as an "active line". An active line is indicated by the pattern '##active_line', followed by the line number. If the pattern is found, it extracts and returns the line number as an integer. If the pattern is not found, it returns None.
            Args:
                line (str): The line of text to be analyzed for the "active line" notation.
            Returns:
                Optional[int]: The line number that has been identified as "active", or None if the pattern is not present.
        """
        if "##active_line" in line:
            return int(line.split("##active_line")[1].split("##")[0])
        return None

    def detect_end_of_execution(self, line):
        return "##end_of_execution##" in line or "##execution_error##" in line
