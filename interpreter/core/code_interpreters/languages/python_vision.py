"""

The `python_vision` module provides an interface to run and manage Python code execution in a separate kernel for dynamic code analysis and output capturing. It facilitates the preprocessing of Python code, execution of code with live updates on the active line and captures various types of output such as textual output, error messages, and various media types. The module handles kernel management and communication with the Jupyter client kernel to execute code in an isolated environment.

Classes:
    PythonVision: A class that encapsulates functionality to start a kernel, execute code, and capture outputs.
    AddLinePrints: A class inheriting from `ast.NodeTransformer` to transform an Abstract Syntax Tree (AST) by inserting print statements that indicate the currently active line of code.

Functions:
    preprocess_python(code): Preprocesses the given Python code to make it suitable for execution with line tracking.
    add_active_line_prints(code): Inserts print statements in the code for tracking active lines during execution.
    wrap_in_try_except(code): Wraps the code in a try-except block to gracefully handle and capture exceptions.

Constants:
    file_extension: A string representing the expected file extension for Python files (default 'py').
    proper_name: A string representing the name of the programming language being executed (default 'Python').


Note: Documentation automatically generated by https://undoc.ai
"""
# Jupyter Python

import ast
import os
import queue
import sys
import threading
import time
import traceback

from jupyter_client import KernelManager

# Supresses a weird debugging error
os.environ["PYDEVD_DISABLE_FILE_VALIDATION"] = "1"
# turn off colors in "terminal"
os.environ["ANSI_COLORS_DISABLED"] = "1"


class PythonVision:
    """
    A class to execute Python code in a kernel and capture its output.
    This class manages a Python kernel session, allowing code execution within a managed environment and capturing all the output produced by the code, including text, errors, images, and HTML. It leverages a message queue to communicate between the execution thread and output capturing procedures.
    Attributes:
        file_extension (str): The default file extension for Python files.
        proper_name (str): The conventional name used for Python.
    Methods:
        __init__(self, config): Initializes the PythonVision instance, starts a Python kernel, and establishes communication channels.
        terminate(self): Stops the communication channels and terminates the Python kernel process.
        run(self, code): Preprocesses the provided code and executes it, capturing the resulting output.
        _execute_code(self, code, message_queue): Private method to execute given code and capture the outputs to a queue using an I/O pub message listener in a separate thread.
        _capture_output(self, message_queue): Private method to yield the captured output from the message queue.
        _old_capture_output(self, message_queue): Private method returning the captured output, kept for legacy support.
        preprocess_code(self, code): Preprocesses the given code.
    Args:
        config (any): Configuration for the PythonVision instance, such as kernel specs or execution options.
    """
    file_extension = "py"
    proper_name = "Python"

    def __init__(self, config):
        """
        Initializes the object with a configuration and starts a new kernel manager.
        This method sets up a kernel manager with a Python 3 kernel and initiates
        communication with it through kernel client channels. It waits until the
        kernel is alive before proceeding, ensuring that communication can be
        established.
        Args:
            config (dict): A dictionary containing configuration parameters.
        Attributes:
            config: Stores the configuration passed to the object during initialization.
            km: An instance of `KernelManager` initialized with `python3` as the kernel name.
            kc: A kernel client associated with the above kernel manager.
        """
        self.config = config
        self.km = KernelManager(kernel_name="python3")
        self.km.start_kernel()
        self.kc = self.km.client()
        self.kc.start_channels()
        while not self.kc.is_alive():
            time.sleep(0.1)
        time.sleep(0.5)

    def terminate(self):
        """
        Terminates the current kernel session by stopping all communication channels and shutting down the kernel.
        This method cleans up the resources by first stopping any active channels that are used to
        communicate with the kernel. After ensuring that all communication is ceased, it proceeds to
        shut down the kernel itself, freeing up any associated resources.
        Note that once the terminate method is called, the object should not be reused as the kernel
        is no longer in a functional state.
        Raises:
            Exception: If any error occurs during the stopping of channels or the shutting down of
            the kernel, the method could raise an exception particular to the implementation of
            the `stop_channels` or `shutdown_kernel` methods.
        """
        self.kc.stop_channels()
        self.km.shutdown_kernel()

    def run(self, code):
        """
            Execute the given code after preprocessing it, captures output, and returns it.
            This method takes a piece of code, preprocesses it through a custom logic and then executes the
            preprocessed code. It is designed to handle asynchronous output from the code execution, capturing
            the output in a queue. After execution, it captures the output from the message queue and returns it.
            Args:
                code (str): The code to be executed.
            Returns:
                Any: The captured output which may include stdout, stderr and other data types returned
                     by the _capture_output method, which processes the message queue populated during the
                     code execution.
        """
        preprocessed_code = self.preprocess_code(code)
        message_queue = queue.Queue()
        self._execute_code(preprocessed_code, message_queue)
        return self._capture_output(message_queue)

    def _execute_code(self, code, message_queue):
        """
        Handles the execution of code within a Jupyter kernel and collection of output messages.
        This function executes a piece of code in an interactive Jupyter kernel and listens for messages on
        the IOPub channel. It gathers different types of output such as stream data, errors, and display data,
        and places them into the given message queue for further handling. The function creates a separate thread
        to listen for IOPub messages that include code execution output, stream data, error information, and
        mime-typed data from execute_result and display_data messages.
        Args:
            code (str): The string of code to be executed in the Jupyter kernel.
            message_queue (queue.Queue): The queue to which the output and other messages will be put.
        """
        def iopub_message_listener():
            """
                Listens to messages from the iopub message channel and processes them accordingly.
                This function continuously monitors the iopub channel for new messages, parses them based on their type, and
                puts processed message content into a queue. It handles different types of messages including standard stream outputs,
                execution errors, and data outputs like images, HTML, or JavaScript. In the case of stream outputs, it also detects
                and processes lines indicating an active line marker. The function runs in an infinite loop, only breaking out
                when a message indicating readiness is received from the shell channel.
                Args:
                    None
                Returns:
                    None
                Raises:
                    queue.Empty: If the get_msg call on the iopub channel times out without receiving a message.
            """
            while True:
                try:
                    msg = self.kc.iopub_channel.get_msg(timeout=0.1)
                    content = msg["content"]

                    if msg["msg_type"] == "stream":
                        # Parse output for active lines first
                        def detect_active_line(line):
                            """
                            Detects an active line marker in a given string.
                            This function searches for an '##active_line' marker within the input string. If found,
                            it extracts the active line number that is immediately followed by '##' and then removes the
                            marker and the active line number from the original string. The function continues to search
                            and process the string until there are no more '##active_line' markers found.
                            Args:
                                line (str): The string to be searched for active line markers.
                            Returns:
                                tuple: A tuple containing the modified string with active line markers removed and the
                                    last active line number detected as an integer. If no marker is found, the active line
                                    number is returned as None.
                            """
                            active_line = None
                            while "##active_line" in line:
                                active_line = int(
                                    line.split("##active_line")[1].split("##")[0]
                                )
                                line = line.replace(
                                    "##active_line" + str(active_line) + "##", ""
                                )
                            return line, active_line

                        line, active_line = detect_active_line(content["text"])

                        if active_line:
                            message_queue.put({"active_line": active_line})

                        message_queue.put({"output": line})
                    elif msg["msg_type"] == "error":
                        message_queue.put({"output": "\n".join(content["traceback"])})
                    elif msg["msg_type"] in ["display_data", "execute_result"]:
                        data = content["data"]
                        if "image/png" in data:
                            #### DISABLED PREFIX
                            # image_base64 = "data:image/png;base64," + data['image/png']
                            # message_queue.put({"image": image_base64})
                            message_queue.put({"image": data["image/png"]})
                        elif "image/jpeg" in data:
                            #### DISABLED PREFIX
                            # image_base64 = "data:image/jpeg;base64," + data['image/jpeg']
                            # message_queue.put({"image": image_base64})
                            message_queue.put({"image": data["image/jpeg"]})
                        elif "text/html" in data:
                            message_queue.put({"html": data["text/html"]})
                        elif "text/plain" in data:
                            message_queue.put({"output": data["text/plain"]})
                        elif "application/javascript" in data:
                            message_queue.put(
                                {"javascript": data["application/javascript"]}
                            )

                except queue.Empty:
                    if self.kc.shell_channel.msg_ready():
                        break

        listener_thread = threading.Thread(target=iopub_message_listener)
        listener_thread.start()

        self.kc.execute(code)
        listener_thread.join()

    def _capture_output(self, message_queue):
        """
            Generator function that continuously captures output from a message queue.
            This function iterates over a message queue, yielding messages as they are available. Between each
            retrieval attempt, the generator will sleep briefly. If no messages are found after a specific
            timeout, the function will perform additional checks followed by short sleep intervals before
            concluding that no further messages will be received and exiting the generator loop.
            Args:
                message_queue (queue.Queue): A queue from which messages will be read. The messages are
                    expected to be placed into this queue by another part of the program.
            Yields:
                Any: The output messages retrieved from the message queue.
        """
        while True:
            if not message_queue.empty():
                yield message_queue.get()
            else:
                time.sleep(0.1)
            try:
                output = message_queue.get(timeout=0.3)  # Waits for 0.3 seconds
                yield output
            except queue.Empty:
                # Try to yank 3 more times from it... maybe there's something in there...
                # (I don't know if this actually helps. Maybe we just need to yank 1 more time)
                for _ in range(3):
                    if not message_queue.empty():
                        yield message_queue.get()
                    time.sleep(0.2)
                break

    def _old_capture_output(self, message_queue):
        """
        Captures the output from a message queue until it's empty.
        This function polls a provided message queue for messages until it is empty, then
        returns the accumulated messages as a list. It uses `get_nowait` method to
        attempt to get messages without blocking, immediately capturing any available
        messages or skipping the iteration if the queue is empty.
        Args:
            message_queue (queue.Queue): The queue from which to get the messages.
        Returns:
            list: A list of accumulated messages from the queue.
        """
        output = []
        while True:
            try:
                line = message_queue.get_nowait()
                output.append(line)
            except queue.Empty:
                break
        return output

    def preprocess_code(self, code):
        """
        Preprocesses the given Python code by applying defined transformations before execution.
        This function serves as a thin wrapper that delegates the preprocessing of Python code to another function that actualizes the required transformations. The goal is to modify the code in a way that facilitates further processing or analysis, such as injecting print statements to monitor execution flow, handling indentation, or other code modifications.
        Args:
            code (str): A string of Python code to preprocess before execution.
        Returns:
            str: The transformed Python code after applying preprocessing steps.
        """
        return preprocess_python(code)


def preprocess_python(code):
    """
    Adds active line prints to the Python code for tracing execution and cleans up the formatting by removing whitespace lines.
        The function takes a string representing Python code, adds print statements to print the current active
        line number during execution, and then cleans up the code by removing lines that are made up entirely of
        whitespace, as this can disrupt the structure of the indented blocks. The modified code is returned as a
        string. This preprocessing is useful for debugging or for creating a more traceable version of the code.
        Args:
            code (str): A string containing the Python code to be preprocessed.
        Returns:
            str: The preprocessed Python code with added active line print statements and without any lines
                consisting solely of whitespace.
    """

    # Add print commands that tell us what the active line is
    code = add_active_line_prints(code)

    # Wrap in a try except
    # code = wrap_in_try_except(code)

    # Remove any whitespace lines, as this will break indented blocks
    # (are we sure about this? test this)
    code_lines = code.split("\n")
    code_lines = [c for c in code_lines if c.strip() != ""]
    code = "\n".join(code_lines)

    return code


def add_active_line_prints(code):
    """
    Transforms Python code to add print statements for active lines.
    This function takes a string representing Python code, parses it into an AST (Abstract Syntax
    Tree), modifies the tree by adding print statements after each line number, and then
    unparses the AST back into a modified code string with the added print statements.
    The print statements take the form of '##active_line<number>##', where <number> is the
    line number of the following statement in the original untransformed code. These active
    line indicators can be used as a debugging aid, allowing the caller to print out indications
    of which lines are being executed at runtime.
    Args:
        code (str): A string of Python source code to be transformed.
    Returns:
        str: The transformed Python code with print statements added after each line of the
            original code.
    """
    tree = ast.parse(code)
    transformer = AddLinePrints()
    new_tree = transformer.visit(tree)
    return ast.unparse(new_tree)


class AddLinePrints(ast.NodeTransformer):
    """
    A NodeTransformer class that traverses an abstract syntax tree (AST) and inserts print statements before each line.
        The AddLinePrints class is designed to augment an existing AST by inserting print function calls at the start of each line of code. This serves as a form of instrumentation that can be helpful for debugging and understanding program execution flow. Every print statement outputs a string which encodes the line number of the subsequent code in a unique format.
        Attributes:
            None
        Methods:
            insert_print_statement(line_number):
                Given a line number, creates an AST node representing a print statement.
            process_body(body):
                Takes a 'body' data structure from an AST node and returns a new list with print statement nodes appropriately interjected.
            visit(node):
                Overrides the NodeTransformer visit method, processes each node to possibly insert print statements, and returns the modified node.
        The visit() method is the entry point for the AST traversal. It makes sure that print statements are inserted before every line in the main body of code, as well as in conditional branches, loops, and exception handling blocks. The specific structure of the inserted print statement can be customized in the insert_print_statement method.
    """

    def insert_print_statement(self, line_number):
        """
        Inserts a print statement into the abstract syntax tree (AST) at a specified line number.
                Args:
                    line_number (int): The target line number where the print statement will be inserted.
                Returns:
                    ast.Expr: An AST expression node representing a print statement.
        """
        return ast.Expr(
            value=ast.Call(
                func=ast.Name(id="print", ctx=ast.Load()),
                args=[ast.Constant(value=f"##active_line{line_number}##")],
                keywords=[],
            )
        )

    def process_body(self, body):
        """
            Processes the provided body of code and inserts print statements.
            This function takes a body of code, which might not necessarily be an iterable collection, and processes
            each element within. If the element has an attribute 'lineno', a print statement is inserted at
            that particular line number. All elements, including possibly prepended print statements,
            are appended to a new list which is then returned.
            Args:
                body (list | any): The body of code to be processed. Can be an iterable list or another type
                                   which will be coerced into a single-element list.
            Returns:
                list: A new list consisting of the original code body elements with print statements
                      inserted where relevant.
        """
        new_body = []

        # In case it's not iterable:
        if not isinstance(body, list):
            body = [body]

        for sub_node in body:
            if hasattr(sub_node, "lineno"):
                new_body.append(self.insert_print_statement(sub_node.lineno))
            new_body.append(sub_node)

        return new_body

    def visit(self, node):
        """
            Visit a node and process its body and any associated blocks.
            This method overrides the visit method of the parent class to process the body of
            the node and any additional blocks associated with it, such as 'orelse' blocks
            in conditional statements and exception handling blocks in 'try' statements.
            Args:
                node (ast.AST): The node to visit and process.
            Returns:
                ast.AST: The processed node with the body and other associated blocks
                potentially modified after processing.
            Note:
                The processing performed on the node's body or blocks depends on the implementation
                of the `process_body` method. Clients of this class are expected to implement the
                `process_body` method accordingly.
            This method specifically:
                - Calls the parent class's visit method to handle the initial visitation.
                - Processes the node's 'body' attribute if it exists.
                - Processes the 'orelse' block if it exists and is not empty.
                - Processes all handlers' body and finalbody attributes for 'try' nodes.
        """
        new_node = super().visit(node)

        # If node has a body, process it
        if hasattr(new_node, "body"):
            new_node.body = self.process_body(new_node.body)

        # If node has an orelse block (like in for, while, if), process it
        if hasattr(new_node, "orelse") and new_node.orelse:
            new_node.orelse = self.process_body(new_node.orelse)

        # Special case for Try nodes as they have multiple blocks
        if isinstance(new_node, ast.Try):
            for handler in new_node.handlers:
                handler.body = self.process_body(handler.body)
            if new_node.finalbody:
                new_node.finalbody = self.process_body(new_node.finalbody)

        return new_node


def wrap_in_try_except(code):
    """
    Wraps a given piece of Python code within a try-except block to capture and print exception tracebacks.
            This function takes a string of Python code, parses it into an Abstract Syntax Tree (AST),
            then wraps the entire code within a single try-except block. If an exception occurs while running the code,
            the catch-all exception handler will be triggered, and the traceback will be printed to the console. The
            modified code is then converted back into a source code string.
            Args:
                code (str): The input Python code to be wrapped in the try-except block.
            Returns:
                str: The transformed Python code with the added try-except block encompassing
                the original code to handle exceptions and print tracebacks.
            Note:
                The function prepends an 'import traceback' statement to the input code to ensure
                the traceback module is available for printing the exception details.
    """
    # Add import traceback
    code = "import traceback\n" + code

    # Parse the input code into an AST
    parsed_code = ast.parse(code)

    # Wrap the entire code's AST in a single try-except block
    try_except = ast.Try(
        body=parsed_code.body,
        handlers=[
            ast.ExceptHandler(
                type=ast.Name(id="Exception", ctx=ast.Load()),
                name=None,
                body=[
                    ast.Expr(
                        value=ast.Call(
                            func=ast.Attribute(
                                value=ast.Name(id="traceback", ctx=ast.Load()),
                                attr="print_exc",
                                ctx=ast.Load(),
                            ),
                            args=[],
                            keywords=[],
                        )
                    ),
                ],
            )
        ],
        orelse=[],
        finalbody=[],
    )

    # Assign the try-except block as the new body
    parsed_code.body = [try_except]

    # Convert the modified AST back to source code
    return ast.unparse(parsed_code)


# Usage
'''
config = {}  # Your configuration here
python_kernel = Python(config)

code = """
import pandas as pd
import numpy as np
df = pd.DataFrame(np.random.rand(10, 5))
# For HTML output
display(df)
# For image output using matplotlib
import matplotlib.pyplot as plt
plt.figure()
plt.plot(df)
plt.savefig('plot.png')  # Save the plot as a .png file
plt.show()
"""
output = python_kernel.run(code)
for line in output:
    display_output(line)
'''
