"""


This module provides functionality to process and run HTML code snippets. It serves as a bridge
between HTML content and displaying it through a web browser or converting it to an image.

The HTML class provided within extends from a base code interpreter class and allows for execution
of the HTML code with additional configurable options. If configured for vision, the HTML code might be
rendered differently or trigger different behaviors, but vision handling is placeholder code in the current
implementation.

The module also performs a simple check to prevent any placeholder text within the HTML from being used,
which is a common error when dynamically generating HTML content.

Classes:
    HTML(BaseCodeInterpreter)
        Extends the base interpreter and handles the running of HTML code within a configurated environment.

Attributes:
    file_extension (str): The file extension associated with HTML files.
    proper_name (str): A proper name to refer to HTML language.

Methods:
    __init__(self, config)
        Initializes the HTML interpreter with the provided configuration settings.

    run(self, code)
        Executes the given HTML code. If vision is enabled in the configuration, specific handling may occur.
        Otherwise, outputs HTML code that can be displayed in a web browser or handled by another function.

Note: This code does not actually render the HTML content itself; it provides the HTML content to
something that can render it, like a web browser or a separate rendering module.

Note: Documentation automatically generated by https://undoc.ai
"""
import base64
import os
import random
import string
import tempfile
import webbrowser

from html2image import Html2Image

from ..base_code_interpreter import BaseCodeInterpreter


class HTML(BaseCodeInterpreter):
    """
    A class responsible for interpreting and processing HTML code based on a given configuration.
        This class extends from a base class, `BaseCodeInterpreter`, and is specialized in handling HTML (HyperText Markup Language) code. It is designed to manage and run HTML code segments, providing the ability to utilize configurations that may impact the execution or validation of the HTML.
        Attributes:
            file_extension (str): A class attribute that denotes the file extension for HTML files, set to 'html'.
            proper_name (str): A class attribute that provides a more formal name for the HTML language, set to 'HTML'.
            config (dict): An instance attribute that holds configuration options which may alter the behavior of the HTML code execution.
        Methods:
            __init__(self, config): Initializes a new instance of the HTML class, setting up the configuration for HTML code execution.
            run(self, code): Executes or interprets the given HTML code, yielding a dictionary with the HTML output if the `vision` configuration is set, or providing warnings about placeholders if present in the code.
    """
    file_extension = "html"
    proper_name = "HTML"

    def __init__(self, config):
        """
            Initialize the class with a given configuration.
            This constructor stores the configuration parameters provided on object creation for later use throughout the class. The constructor also calls the superclass' initialization method.
            Args:
                config (dict): A dictionary containing configuration parameters.
        """
        super().__init__()
        self.config = config

    def run(self, code):
        """
        Runs the given code with the current configuration and yields the processed output.
            This method takes a piece of code and potentially processes it based on the configuration of the object. If the 'vision' key in the config dictionary is set to True, additional processing may occur. The method is currently not fully implemented, as indicated by the 'pass' statement. There is also a commented out section that was intended to yield a warning when placeholders are detected in the HTML code, but this is disabled due to placeholders being common in normal HTML elements.
            The method finally yields the input code wrapped in a dictionary with the key 'html', indicating the code is to be treated as HTML content. It is indicated that HTML is an acceptable form of output, with the expectation that the terminal interface will handle the rendering.
            Args:
                code (str): The piece of code to be executed and/or processed.
            Yields:
                dict: A dictionary containing the processed HTML code with the key 'html'.
        """
        ## This has been offloaded to the terminal interface
        # Create a temporary HTML file with the content
        # with tempfile.NamedTemporaryFile(delete=False, suffix=".html") as f:
        #     f.write(code.encode())

        # # Open the HTML file with the default web browser
        # webbrowser.open("file://" + os.path.realpath(f.name))

        # yield {
        #     "output": f"Saved to {os.path.realpath(f.name)} and opened with the user's default web browser."
        # }

        if self.config["vision"]:
            pass

            # disabled because placeholder is a normal html element lol. how to fix this?
            # Warn LLM about placeholders.
            # if "placeholder" in code.lower() or "will go here" in code.lower():
            #     yield {
            #         "output": "\n\nWARNING TO LLM: Placeholder detected. Do NOT use placeholders in HTML code, write the users entire request at once."
            #     }

            # Lmao this is so thin. But html should be accepted output, it's actually terminal interface that will figure out how to render it

        yield {"html": code}
