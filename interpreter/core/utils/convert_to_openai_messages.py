"""

Converts a list of chat messages into a format that is compatible with OpenAI's format, optionally allowing the execution of embedded code blocks.

Args:
    messages (list of dict): A list of message dictionaries where each message contains keys such as 'role', 'message', 'code', 'language', 'output', and 'image' describing the content and the metadata of the message.
    function_calling (bool, optional): A flag indicating whether to convert code blocks within messages into function calls for execution. Defaults to True.

Returns:
    list of dict: A list of new message dictionaries formatted according to the specified function_calling argument. Each dictionary contains keys 'role', 'content', and optionally 'function_call' or 'image_url' depending on the original messages' contents and the function_calling argument.

    The 'role' field indicates whether the message is from the 'user' or the 'assistant'. The 'content' field contains the message text or a list with an 'image_url' or 'text' dictionary

    If function_calling is True, messages with 'code' are converted to 'function_call' dictionaries with 'name', 'arguments', and 'parsed_arguments'. If function_calling is False, code blocks are included as markdown-formatted strings within the 'content'.

    Messages with 'output' are handled differently based on the function_calling flag. If function_calling is True, they are separated into their own message with a 'function' role. Otherwise, they are appended to the 'content' of the message preceding them with an explanatory text.

    'image' key in the original message is converted into an 'image_url' type with appropriate fields within the 'content' list, and placed appropriately based on the 'role'.

    The conversion process also includes additional logic to format the messages, trim unnecessary content, and organize the message contents as per OpenAI's standards.

Note: Documentation automatically generated by https://undoc.ai
"""
import json


def convert_to_openai_messages(messages, function_calling=True):
    """
    Converts a list of messages to the format expected by OpenAI, with an option to include function calling syntax.
        The function processes a list of message dictionaries and converts them to a format that is compatible with OpenAI messaging. Each message may contain a role, content, and optionally, code or an image. The function can also handle formatting the output of executed code as new messages. If function_calling is enabled, code blocks and their executions are formatted as function calls, otherwise, they are added as content with markdown code block syntax.
        Args:
            messages (list of dict): A list of message dictionaries to be converted.
            function_calling (bool): A flag indicating whether to use function calling syntax for code blocks (True) or plain markdown (False).
        Returns:
            list of dict: The messages converted to the OpenAI message format.
    """
    new_messages = []

    for message in messages:
        new_message = {"role": message["role"], "content": ""}

        if "message" in message and "image" not in message:
            new_message["content"] = message["message"]

        if "code" in message:
            if function_calling:
                new_message["function_call"] = {
                    "name": "execute",
                    "arguments": json.dumps(
                        {"language": message["language"], "code": message["code"]}
                    ),
                    # parsed_arguments isn't actually an OpenAI thing, it's an OI thing.
                    # but it's soo useful! we use it to render messages to text_llms
                    "parsed_arguments": {
                        "language": message["language"],
                        "code": message["code"],
                    },
                }
            else:
                new_message[
                    "content"
                ] += f"""\n\n```{message["language"]}\n{message["code"]}\n```"""
                new_message["content"] = new_message["content"].strip()

        new_messages.append(new_message)

        if "output" in message:
            if function_calling:
                new_messages.append(
                    {
                        "role": "function",
                        "name": "execute",
                        "content": message["output"],
                    }
                )
            else:
                if message["output"] == "No output":
                    content = "The code above was executed on my machine. It produced no output. Was that expected?"
                else:
                    content = (
                        "Code output: "
                        + message["output"]
                        + "\n\nWhat does this output mean / what's next (if anything, or are we done)?"
                    )

                new_messages.append(
                    {
                        "role": "user",
                        "content": content,
                    }
                )

        if "image" in message:
            new_message = {
                "role": "user",
                "content": [
                    {
                        "type": "image_url",
                        "image_url": {"url": message["image"], "detail": "high"},
                    }
                ],
            }

            if message["role"] == "user":
                if "message" in message:
                    new_message["content"].append(
                        {
                            "type": "text",
                            "text": message["message"],
                        }
                    )
                    new_message[
                        "content"
                    ].reverse()  # Text comes first in OpenAI's docs. IDK if this is important.

                new_messages.append(new_message)

            if message["role"] == "assistant":
                if message == messages[-1]:
                    # DISABLED self-improving image message (it loops forever)
                    # Save some tokens and be less repetitive by only adding this to the last message
                    """
                    new_message["content"].append(
                        {
                            "type": "text",
                            "text": "This is the result. Does that look right? Could it be closer to what we're aiming for, or is it done? Be detailed in exactly how we could improve it first, then write code to improve it. Unless you think it's done (I might agree)!",
                        }
                    )
                    new_message[
                        "content"
                    ].reverse()  # Text comes first in OpenAI's docs. IDK if this is important.
                    """
                    pass

                new_messages.append(new_message)

                if "output" in message and message == messages[-1]:
                    pass
                    # This is hacky, but only display the message if it's the placeholder warning for now:
                    # if (
                    #     "placeholder" in message["output"].lower()
                    #     or "traceback" in message["output"].lower()
                    # ) and "text" in new_messages[-1]["content"][0]:
                    #     new_messages[-1]["content"][0]["text"] += (
                    #         "\n\nAlso, I recieved this output from the Open Interpreter code execution system we're using, which executes your markdown code blocks automatically: "
                    #         + message["output"]
                    #     )

    if not function_calling:
        new_messages = [
            msg for msg in new_messages if "content" in msg and len(msg["content"]) != 0
        ]

    return new_messages
