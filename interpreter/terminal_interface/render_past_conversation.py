"""

Module render_past_conversation.

This module provides functionality to render past conversations between a user and a code execution environment. It makes use of various components such as code blocks and message blocks to visually present the conversation in a readable format.

The module interfaces with classes CodeBlock and MessageBlock to handle the code and message chunks, respectively, and uses the utility function `display_markdown_message` from the utils package to process markdown formatted messages.

The primary function of this module, `render_past_conversation`, takes a list of message chunks representing the conversation history. Each chunk is a dict containing details such as the sender's role, the message content, and, if applicable, code data including the programming language, code snippet, and output. The function iterates over these chunks, formatting and displaying them appropriately in sequence, handling user messages, code executions, and outputs, and indicating when the code execution blocks start and end.

Note: A detailed interaction flow is available through the docstrings of CodeBlock and MessageBlock classes, and the `display_markdown_message` utility function.

Note: Documentation automatically generated by https://undoc.ai
"""
from .components.code_block import CodeBlock
from .components.message_block import MessageBlock
from .utils.display_markdown_message import display_markdown_message


def render_past_conversation(messages):
    """
    Handles rendering the past conversation from a series of message chunks.
        Each message chunk represents either a user message, a code block, or an output from previous interaction blocks. This function iterates through the provided message chunks and prints user messages as well as instantiates and refreshes message or code blocks as necessary based on the content encountered in the chunks.
        User messages are printed with a '>' prefix. Message and code blocks are ended before a new block of the same or different type is started. For code blocks, the function also manages the state of the cursor and keeps track of whether a code block has been run in order to decide when to refresh or end blocks.
        The function accounts for active lines and code outputs and ensures proper ending of active blocks after processing all chunks.
        Args:
            messages (list of dict): An array of message chunks where each chunk is a dictionary containing different keys such as 'role', 'message', 'code', 'language', 'active_line', and 'output' corresponding to different parts of the past conversation.
    """
    # This is a clone of the terminal interface.
    # So we should probably find a way to deduplicate...

    active_block = None
    render_cursor = False
    ran_code_block = False

    for chunk in messages:
        # Only addition to the terminal interface:
        if chunk["role"] == "user":
            if active_block:
                active_block.end()
                active_block = None
            print(">", chunk["message"])
            continue

        # Message
        if "message" in chunk:
            if active_block is None:
                active_block = MessageBlock()
            if active_block.type != "message":
                active_block.end()
                active_block = MessageBlock()
            active_block.message += chunk["message"]

        # Code
        if "code" in chunk or "language" in chunk:
            if active_block is None:
                active_block = CodeBlock()
            if active_block.type != "code" or ran_code_block:
                # If the last block wasn't a code block,
                # or it was, but we already ran it:
                active_block.end()
                active_block = CodeBlock()
            ran_code_block = False
            render_cursor = True

        if "language" in chunk:
            active_block.language = chunk["language"]
        if "code" in chunk:
            active_block.code += chunk["code"]
        if "active_line" in chunk:
            active_block.active_line = chunk["active_line"]

        # Output
        if "output" in chunk:
            ran_code_block = True
            render_cursor = False
            active_block.output += "\n" + chunk["output"]
            active_block.output = active_block.output.strip()  # <- Aesthetic choice

        if active_block:
            active_block.refresh(cursor=render_cursor)

    # (Sometimes -- like if they CTRL-C quickly -- active_block is still None here)
    if active_block:
        active_block.end()
        active_block = None
