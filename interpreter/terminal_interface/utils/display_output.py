"""

Converts the given output (text, image, HTML, or JavaScript) to a human-readable format, displaying it appropriately based on the environment (Jupyter notebook or command-line interface). It uses various techniques to interpret and render the output, utilizing libraries such as IPython for Jupyter notebooks and subprocess for command-line environments, alongside temporary file handling for displaying images, HTML, and JavaScript contents in their respective applications. The module also includes a utility function to detect if the code is running within a Jupyter notebook environment.

Note: Documentation automatically generated by https://undoc.ai
"""
import base64
import os
import platform
import subprocess
import tempfile


def display_output(output):
    """
        Displays output data in an appropriate format depending on the environment.
        This function determines whether the user is running in a Jupyter notebook environment or a
        command-line interface (CLI) and displays the given output accordingly. If running within
        Jupyter, it makes use of IPython's display tools for rendering HTML, images, and Javascript.
        If running from the CLI, it saves files to temporary files and opens them externally.
        Args:
            output (dict): A dictionary containing the output to display with keys such as 'output',
                'image', 'html', 'javascript', indicating the type of content and associated data.
        Returns:
            str: A message that indicates the output has been displayed or details about any
                temporary files created during the process.
        Raises:
            None explicitly, but may raise depending on the underlying library calls used for
                displaying outputs or handling files.
    """
    if is_running_in_jupyter():
        from IPython.display import HTML, Image, Javascript, display

        if "output" in output:
            print(output["output"])
        elif "image" in output:
            # Decode the base64 image data
            image_data = base64.b64decode(output["image"])
            display(Image(image_data, format="png"))
        elif "html" in output:
            display(HTML(output["html"]))
        elif "javascript" in output:
            display(Javascript(output["javascript"]))
    else:
        display_output_cli(output)

    # Return a message for the LLM.
    # We should make this specific to what happened in the future,
    # like saying WHAT temporary file we made, ect. Keep the LLM informed.
    return "Displayed on the user's machine."


def display_output_cli(output):
    """
        Displays a given output in the CLI and handles different output data types.
        This function processes the given output dictionary and acts based on its content. If the output
        dictionary contains 'output', it prints the text output to the console. If it contains 'image',
        it decodes the base64-encoded image, saves it as a temporary PNG file and opens it using the
        default image viewer. If it contains 'html', it saves it as a temporary HTML file and opens it
        with the default HTML viewer. Finally, if it contains 'javascript', it saves the JavaScript content
        as a temporary .js file and tries to open it.
        All temporary files created during this process are configured to not be deleted automatically.
        Args:
            output (dict): A dictionary with keys corresponding to the type of output to display.
                May contain the following keys with corresponding values:
                - 'output': A string representing text output.
                - 'image': A base64-encoded string representing image data.
                - 'html': A string containing HTML content.
                - 'javascript': A string containing JavaScript code.
        Raises:
            This function does not raise any errors on its own, but it prints error messages if there are
            issues opening the temporary files.
    """
    if "output" in output:
        print(output["output"])
    elif "image" in output:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".png") as tmp_file:
            image_data = output["image"]
            tmp_file.write(base64.b64decode(image_data))
            open_file(tmp_file.name)
            print(f"Image saved and opened from {tmp_file.name}")
    elif "html" in output:
        with tempfile.NamedTemporaryFile(
            delete=False, suffix=".html", mode="w"
        ) as tmp_file:
            html = output["html"]
            if "<html>" not in html:
                html = "<html>\n" + html + "\n</html>"
            tmp_file.write(html)
            open_file(tmp_file.name)
            print(f"HTML content saved and opened from {tmp_file.name}")
    elif "javascript" in output:
        with tempfile.NamedTemporaryFile(
            delete=False, suffix=".js", mode="w"
        ) as tmp_file:
            tmp_file.write(output["javascript"])
            open_file(tmp_file.name)
            print(f"JavaScript content saved and opened from {tmp_file.name}")


def open_file(file_path):
    """
    Handles incoming stream data for both standard and error streams.
        This method processes lines read from a stream, such as standard output or
        standard error of a subprocess. It determines whether the line should be processed,
        discarded, or identified as a special case (such as end of execution signal).
        Processed lines may be added to an output queue or may trigger setting a
        'done' event in case the end of the output stream is detected.
        Args:
            stream (io.IOBase): The stream to read from. This should be a file-like
                object with a `readline` method.
            is_error_stream (bool): A flag indicating whether the stream is standard error.
                This is used to handle error lines, such as KeyboardInterrupt, differently.
        This method does not return any values. It sends output to a queue and may set
        an event to indicate the end of processing.
    """
    try:
        if platform.system() == "Windows":
            os.startfile(file_path)
        elif platform.system() == "Darwin":  # macOS
            subprocess.run(["open", file_path])
        else:  # Linux and other Unix-like
            subprocess.run(["xdg-open", file_path])
    except Exception as e:
        print(f"Error opening file: {e}")


def is_running_in_jupyter():
    """
    Detects if the current environment is a Jupyter notebook.
    Returns:
        bool: True if running inside a Jupyter notebook, False otherwise.
    Raises:
        Any exception raised by importing IPython or accessing its configuration is
        caught, and False is returned in such cases, implying not running within Jupyter.
    """
    try:
        from IPython import get_ipython

        if "IPKernelApp" in get_ipython().config:
            print("You are in Jupyter.")
            return True
    except:
        return False
