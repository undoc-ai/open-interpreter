"""

A module that defines magic commands, providing specialized actions such as interacting with the system, manipulating message history, and displaying system and interpreter information in the framework of an interactive interpreter application like a shell or REPL environment.

This module includes commands for:
- Executing shell commands within the application's environment.
- Enabling or disabling debug mode, affecting verbosity of output and error reporting.
- Resetting the current interactive session to its initial state.
- Undoing user actions by removing messages from the session history.
- Saving the current session messages to a JSON file for later retrieval or review.
- Loading messages from a JSON file to restore a previous session state.
- Counting tokens used in a conversation and estimating the cost of the messages for systems with token-based billing.
- Displaying a help message outlining available commands and their use.
- Providing detailed system and interpreter information such as version numbers and environment details.

Functions in this module react to user input prefixed with `%` or `%%`, indicating a magic command. They decode the command input, locate the corresponding action, and execute the function associated to the command keyword or signal an error for unrecognized commands.

Note: Documentation automatically generated by https://undoc.ai
"""
import json
import os
import subprocess

from .utils.count_tokens import count_messages_tokens
from .utils.display_markdown_message import display_markdown_message
from ..core.utils.system_debug_info import system_info


def handle_undo(self, arguments):
    """
    Handles the 'undo' action by reverting the state to the point before the last user message.
        This method scans through the list of messages maintained by the instance, identifies the last message
        with 'role': 'user', and removes all messages that come after it. It will also print a preview of
        the messages being removed for user reference.
        Args:
            arguments: Additional arguments that might be required for the method (not used here).
        Side Effects:
            Modifies the self.messages to remove the messages which are reverted by the undo operation.
            Prints out the messages that were removed, so the user has feedback about what was undone.
    """
    # Removes all messages after the most recent user entry (and the entry itself).
    # Therefore user can jump back to the latest point of conversation.
    # Also gives a visual representation of the messages removed.

    if len(self.messages) == 0:
        return
    # Find the index of the last 'role': 'user' entry
    last_user_index = None
    for i, message in enumerate(self.messages):
        if message.get("role") == "user":
            last_user_index = i

    removed_messages = []

    # Remove all messages after the last 'role': 'user'
    if last_user_index is not None:
        removed_messages = self.messages[last_user_index:]
        self.messages = self.messages[:last_user_index]

    print("")  # Aesthetics.

    # Print out a preview of what messages were removed.
    for message in removed_messages:
        if "content" in message and message["content"] != None:
            display_markdown_message(
                f"**Removed message:** `\"{message['content'][:30]}...\"`"
            )
        elif "function_call" in message:
            display_markdown_message(
                f"**Removed codeblock**"
            )  # TODO: Could add preview of code removed here.

    print("")  # Aesthetics.


def handle_help(self, arguments):
    """
    Handles the display of help information for available commands.
    This method processes a set of predefined commands and their descriptions, then
    assembles a help message detailing the purpose of each command. The constructed
    message includes both the base command, its usage, and any additional guidance
    or information. Once the help message is composed, it is displayed to the user
    in a rich markdown format. If the user requires more detailed assistance or
    wishes to contribute to the project, they are directed to the community Discord
    or the project's development resources.
    Args:
        arguments (Any): Placeholder for future use, currently not utilized within the function.
    """
    commands_description = {
        "%% [commands]": "Run commands in system shell",
        "%debug [true/false]": "Toggle debug mode. Without arguments or with 'true', it enters debug mode. With 'false', it exits debug mode.",
        "%reset": "Resets the current session.",
        "%undo": "Remove previous messages and its response from the message history.",
        "%save_message [path]": "Saves messages to a specified JSON path. If no path is provided, it defaults to 'messages.json'.",
        "%load_message [path]": "Loads messages from a specified JSON path. If no path is provided, it defaults to 'messages.json'.",
        "%tokens [prompt]": "EXPERIMENTAL: Calculate the tokens used by the next request based on the current conversation's messages and estimate the cost of that request; optionally provide a prompt to also calulate the tokens used by that prompt and the total amount of tokens that will be sent with the next request",
        "%help": "Show this help message.",
        "%info": "Show system and interpreter information",
    }

    base_message = ["> **Available Commands:**\n\n"]

    # Add each command and its description to the message
    for cmd, desc in commands_description.items():
        base_message.append(f"- `{cmd}`: {desc}\n")

    additional_info = [
        "\n\nFor further assistance, please join our community Discord or consider contributing to the project's development."
    ]

    # Combine the base message with the additional info
    full_message = base_message + additional_info

    display_markdown_message("".join(full_message))


def handle_debug(self, arguments=None):
    """
        Handles the toggling of debug mode based on the provided arguments.
        This function is responsible for setting the object's debug mode attribute based on the arguments
        passed. If the arguments indicate to enter debug mode, a markdown message indicating entry into
        debug mode is displayed and the messages held by the object are printed. If the arguments indicate
        to exit debug mode, a markdown message indicating exit from debug mode is displayed, and the debug
        mode state is set to False. If the provided arguments do not match expected values, a markdown
        message indicating this is displayed.
        Args:
            arguments (str, optional): The argument to determine if debug mode should be turned on or off.
                It accepts 'true' to enable debug mode, 'false' to disable it, and '' is treated as 'true'.
                The default value is None, but passing an unrecognized string will result in a markdown message
                notifying the user of an unknown argument.
        Returns:
            None
    """
    if arguments == "" or arguments == "true":
        display_markdown_message("> Entered debug mode")
        print(self.messages)
        self.debug_mode = True
    elif arguments == "false":
        display_markdown_message("> Exited debug mode")
        self.debug_mode = False
    else:
        display_markdown_message("> Unknown argument to debug command.")

def handle_info(self, arguments):
    """
        Handles the collection and display of system information based on the provided interpreter.
        This function calls `system_info` with the `interpreter` argument to collect
        and print relevant system details that includes versions of Python, Pip,
        and the Open-interpreter, as well as the OS version, CPU, and RAM info. It is
        typically used for diagnostic purposes to understand the environment in which
        the interpreter is running.
        Args:
            interpreter (object): An object or identifier for the interpreter whose
                details are to be fetched and displayed.
        Returns:
            None
    """
    system_info(self)


def handle_reset(self, arguments):
    """
    Handles the reset operation for an object, and afterward, displays a reset completion message.
    This function serves to reset the state of the object using its internal `reset` method and
    notifies that the reset operation has been completed by displaying a markdown message using the
    `display_markdown_message` function.
    Args:
        arguments (Any): The arguments passed to the reset function. Currently not used in the function body.
    Returns:
        None
    """
    self.reset()
    display_markdown_message("> Reset Done")


def default_handle(self, arguments):
    """
    Handles the default case when an unknown command is passed.
    This function is called when the input arguments do not match any known command.
    It displays a message indicating that the command is unknown and then calls the
    `handle_help` function to show the help message with available commands to the user.
    Args:
        self:
            The instance of the class within which the function operates.
            Allows access to class attributes and other methods.
        arguments:
            A list or collection of arguments that were passed along with the
            unknown command. This is not used within this function but is
            passed to the `handle_help` function.
    """
    display_markdown_message("> Unknown command")
    handle_help(self, arguments)


def handle_save_message(self, json_path):
    """
    Handles saving messages data to a JSON file.
    This method will take a provided file path or default to 'messages.json' if an empty
    string is passed. It will append '.json' to the file name if it's not already present.
    Once the file name is ensured to end with '.json', the messages stored in
    self.messages are then serialized into JSON format and written to the specified file.
    After writing the data, it also displays a message stating the path to which the
    messages JSON was exported.
    Args:
        json_path (str): The file path where to save the JSON data. If an empty
            string is provided, it defaults to 'messages.json' in the current directory.
    Raises:
        IOError: If the file could not be written.
    """
    if json_path == "":
        json_path = "messages.json"
    if not json_path.endswith(".json"):
        json_path += ".json"
    with open(json_path, "w") as f:
        json.dump(self.messages, f, indent=2)

    display_markdown_message(f"> messages json export to {os.path.abspath(json_path)}")


def handle_load_message(self, json_path):
    """
        Loads messages from a specified JSON file into the class instance.
        This function checks whether the provided `json_path` is a valid path to a JSON file,
        appending `.json` if it is not present. It reads the JSON file and stores the parsed
        messages into an attribute of the class. After loading, it displays a success message
        with the absolute path of the loaded file.
        Args:
            json_path (str): The path to the JSON file that contains the messages to be loaded.
                Defaults to 'messages.json' if an empty string is provided.
        Raises:
            FileNotFoundError: If the specified JSON file does not exist.
            json.JSONDecodeError: If the JSON file contains invalid JSON and cannot be parsed.
    """
    if json_path == "":
        json_path = "messages.json"
    if not json_path.endswith(".json"):
        json_path += ".json"
    with open(json_path, "r") as f:
        self.messages = json.load(f)

    display_markdown_message(
        f"> messages json loaded from {os.path.abspath(json_path)}"
    )


def handle_count_tokens(self, prompt):
    """
    Handles the counting of the message tokens and calculates the token cost for conversations.
    This method takes the current conversation context, which includes system messages and user messages, and calculates the total token usage for both the conversation context and the provided prompt (if any). It then estimates the cost based on the model's token pricing. After the computation, it formats the counts and the cost estimates into a markdown message and displays it to the user. This function uses the `count_messages_tokens` for token counting and `token_cost` for calculating the cost. Additionally, it appends a note about the experimental status of this feature and provides a link for reporting issues on the related GitHub repository.
    Args:
        prompt (str, optional): The latest prompt that is intended to be included in the token count. This will be added to the message history for the calculation.
    Generates:
        markdown_output (Markdown): A formatted text output which includes token count and estimated cost for the conversation's context, the prompt, and the total if a prompt is provided. It will also add a note on the experimental functionality.
    No return value as the function's output is the display of the markdown message to the user.
    """
    messages = [{"role": "system", "message": self.system_message}] + self.messages

    outputs = []

    if len(self.messages) == 0:
        (conversation_tokens, conversation_cost) = count_messages_tokens(
            messages=messages, model=self.model
        )
    else:
        (conversation_tokens, conversation_cost) = count_messages_tokens(
            messages=messages, model=self.model
        )

    outputs.append(
        (
            f"> Tokens sent with next request as context: {conversation_tokens} (Estimated Cost: ${conversation_cost})"
        )
    )

    if prompt:
        (prompt_tokens, prompt_cost) = count_messages_tokens(
            messages=[prompt], model=self.model
        )
        outputs.append(
            f"> Tokens used by this prompt: {prompt_tokens} (Estimated Cost: ${prompt_cost})"
        )

        total_tokens = conversation_tokens + prompt_tokens
        total_cost = conversation_cost + prompt_cost

        outputs.append(
            f"> Total tokens for next request with this prompt: {total_tokens} (Estimated Cost: ${total_cost})"
        )

    outputs.append(
        f"**Note**: This functionality is currently experimental and may not be accurate. Please report any issues you find to the [Open Interpreter GitHub repository](https://github.com/KillianLucas/open-interpreter)."
    )

    display_markdown_message("\n".join(outputs))

def handle_shell(self, code):
    """
    Handles the execution of a shell command.
    This method executes a shell command passed in as a string using the `subprocess.run` function from the `subprocess` module. It captures the standard output and standard error streams. After execution, the standard output and standard error are decoded to a string and printed to the console.
    Args:
        code (str): The shell command to be executed as a string.
    Returns:
        None: This method does not return anything.
    """
    result = subprocess.run(code, shell=True, capture_output=True)

    if result.stdout:
        print(result.stdout.decode())

    if result.stderr:
        print(result.stderr.decode())

def handle_magic_command(self, user_input):
    """
    Handles the execution of magic commands entered by the user.
    This method interprets a string input that starts with '%%' as a shell command and executes it directly using the `subprocess` module. For the magic commands that start with '%', the method parses the command and its arguments. It then looks up the command in a predefined dictionary of magic commands, executing the associated function if found, or a default handler if the command is not recognized. The functionalities of these commands can include, but are not limited to, providing help, toggling debug mode, resetting some state, saving or loading messages, undoing an action, counting tokens, and displaying information.
    Args:
        user_input (str): The input string entered by the user that starts with either '%%' for shell commands or '%' for magic commands.
    Returns:
        None
    """
    # Handle shell
    if user_input.startswith("%%"):
        handle_shell(self,user_input[2:])
        return

    # split the command into the command and the arguments, by the first whitespace
    switch = {
        "help": handle_help,
        "debug": handle_debug,
        "reset": handle_reset,
        "save_message": handle_save_message,
        "load_message": handle_load_message,
        "undo": handle_undo,
        "tokens": handle_count_tokens,
        "info": handle_info,
    }

    user_input = user_input[1:].strip()  # Capture the part after the `%`
    command = user_input.split(" ")[0]
    arguments = user_input[len(command) :].strip()
    action = switch.get(
        command, default_handle
    )  # Get the function from the dictionary, or default_handle if not found
    action(self, arguments)  # Execute the function
